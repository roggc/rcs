import { r as reactExports } from '../../react/index.js';
import * as reduxToolkit_esm from '../../@reduxjs/toolkit/dist/redux-toolkit.esm.js';
import '../../react-redux/es/index.js';
import Provider from '../../react-redux/es/components/Provider.js';
import '../../hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js';
import '../../react-is/index.js';
import { createDispatchHook } from '../../react-redux/es/hooks/useDispatch.js';
import { createSelectorHook } from '../../react-redux/es/hooks/useSelector.js';

const { configureStore, createSlice: createReduxSlice } = reduxToolkit_esm;
const __SET_INIT_PERSISTED_STATE_RN__ = "__SET_INIT_PERSISTED_STATE_RN__";
const createReduxSliceWrapper = (name, reducers, initialState) => {
    const reduxSlice = {
        [name]: createReduxSlice({ name, initialState, reducers }),
    };
    const useValues = (slice) => ({});
    const useActions = () => ({});
    const Provider = ({ children }) => reactExports.createElement(reactExports.Fragment, null, children);
    return {
        useValues,
        useActions,
        Provider,
        reduxSlice,
    };
};
const createSlice = (reducer, initialArg, init, name, getUseActions, isGetInitialStateFromStorage, AsyncStorage, middleware = []) => {
    const reduxSlice = {};
    const StateContext = reactExports.createContext({});
    const DispatchContext = reactExports.createContext(() => {
        console?.log("You must use the Provider up in the tree");
    });
    const useStateContext = (slice) => reactExports.useContext(slice === name ? StateContext : {});
    const useDispatchContext = () => reactExports.useContext(DispatchContext);
    const useValues = (slice) => {
        const state = useStateContext(slice);
        return state ?? {};
    };
    const useActions = getUseActions(useDispatchContext);
    let initialState_;
    if (isGetInitialStateFromStorage && !AsyncStorage) {
        let item;
        (item = localStorage.getItem(name)) !== null &&
            (initialState_ = JSON.parse(item));
    }
    const Provider = ({ children }) => {
        const reducerWrapper = (reducer) => (state, action) => !!action && action.type === __SET_INIT_PERSISTED_STATE_RN__
            ? reducer(action.payload, action)
            : reducer(state, action);
        const [state, dispatch] = reactExports.useReducer(!!AsyncStorage & isGetInitialStateFromStorage
            ? reducerWrapper(reducer)
            : reducer, initialState_ !== undefined ? initialState_ : initialArg, initialState_ !== undefined ? undefined : init);
        const enhancedDispatch = reactExports.useCallback(middleware
            .map((middleware) => middleware((action) => enhancedDispatch(action)))
            .reduceRight((dispatch, middleware) => middleware(dispatch), dispatch), [dispatch]);
        reactExports.useEffect(() => {
            if (isGetInitialStateFromStorage && !!AsyncStorage) {
                (async () => {
                    let item;
                    let updateState;
                    (item = await AsyncStorage?.getItem?.(name)) !== null &&
                        (updateState = JSON.parse(item));
                    return updateState;
                })().then((updateState) => updateState !== undefined &&
                    dispatch({
                        type: __SET_INIT_PERSISTED_STATE_RN__,
                        payload: updateState,
                    }));
            }
        }, []);
        return (reactExports.createElement(StateContext.Provider, { value: { [name]: state } },
            reactExports.createElement(DispatchContext.Provider, { value: enhancedDispatch }, children)));
    };
    return {
        useValues,
        useActions,
        Provider,
        reduxSlice,
    };
};
const composeProviders = (providers) => {
    const NeutralProvider = ({ children }) => reactExports.createElement(reactExports.Fragment, null, children);
    return providers.reduce((AccProvider, Provider) => ({ children }) => (reactExports.createElement(Provider, null,
        reactExports.createElement(AccProvider, null, children))), NeutralProvider);
};
const createTypicalSlice = (name, initialArg, reducer, init, isGetInitialStateFromStorage, AsyncStorage, middleware) => {
    const SET = "SET";
    const reducer_ = reducer ??
        ((state, { type, payload }) => {
            switch (type) {
                case SET:
                    return typeof payload === "function" ? payload(state) : payload;
                default:
                    return state;
            }
        });
    const { useValues, useActions, Provider, reduxSlice } = createSlice(reducer_, initialArg, init, name, (useDispatch) => () => {
        const dispatch = useDispatch();
        const set = reactExports.useCallback((value) => dispatch({ type: SET, payload: value }), [dispatch]);
        return !!reducer ? { [name]: { dispatch } } : { [name]: { set } };
    }, isGetInitialStateFromStorage, AsyncStorage, middleware);
    return { useValues, useActions, Provider, reduxSlice };
};
const getHookAndProviderFromSlices = ({ slices = {}, AsyncStorage = null, reduxStoreOptions = {}, }) => {
    const { useValues, useActions, providers, reduxSlices } = Object.entries(slices)
        .map(([name, { initialArg, reducer, isGetInitialStateFromStorage, init, middleware, initialState, reducers, },]) => !!reducers
        ? createReduxSliceWrapper(name, reducers, initialState)
        : createTypicalSlice(name, initialArg, reducer, init, !!isGetInitialStateFromStorage, AsyncStorage, middleware))
        .reduce((res, values) => ({
        useValues: (slice) => ({
            ...res.useValues(slice),
            ...values.useValues(slice),
        }),
        useActions: () => ({ ...res.useActions(), ...values.useActions() }),
        providers: [...res.providers, values.Provider],
        reduxSlices: [...res.reduxSlices, values.reduxSlice],
    }), {
        useValues: (slice) => ({}),
        useActions: () => ({}),
        providers: [],
        reduxSlices: [],
    });
    const SpecificContext = reactExports.createContext(null);
    const useDispatch = createDispatchHook(SpecificContext);
    const useSelector = createSelectorHook(SpecificContext);
    const useContextSlice = (name) => {
        const { [name]: value } = useValues(name);
        const { [name]: actions } = useActions();
        return [value, !!slices[name]?.reducer ? actions.dispatch : actions?.set];
    };
    const useSlice = (name, selector = (state) => state) => {
        const reduxSlice = reduxSlices.find((rS) => !!rS[name]);
        if (!!reduxSlice) {
            const preSelector = (state) => state[name];
            return [
                useSelector((state) => selector(preSelector(state))),
                useDispatch(),
                reduxSlice[name].actions,
            ];
        }
        return useContextSlice(name);
    };
    const ReduxProviderWrapper = ({ children }) => {
        const reducer = reactExports.useMemo(() => reduxSlices.reduce((res, rS) => ({
            ...res,
            ...(!!Object.keys(rS).length
                ? { [Object.keys(rS)[0]]: Object.values(rS)[0].reducer }
                : rS),
        }), {}), [reduxSlices]);
        if (!Object.keys(reducer).length) {
            return reactExports.createElement(reactExports.Fragment, null, children);
        }
        const store = reactExports.useMemo(() => configureStore({
            reducer,
            ...reduxStoreOptions,
        }), [reducer, reduxStoreOptions]);
        return (reactExports.createElement(Provider, { context: SpecificContext, store: store }, children));
    };
    const Provider$1 = composeProviders([...providers, ReduxProviderWrapper]);
    return {
        useSlice,
        Provider: Provider$1,
    };
};

export { getHookAndProviderFromSlices as default };
